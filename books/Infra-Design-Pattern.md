# インフラデザインパターン

[![インフラデザインパターン ~安定稼動に導く127の設計方式 (WEB+DB PRESS plus)](http://ecx.images-amazon.com/images/I/51%2BITF6dZ%2BL._SL160_.jpg) インフラデザインパターン ~安定稼動に導く127の設計方式 (WEB+DB PRESS plus)](http://www.amazon.co.jp/exec/obidos/ASIN/4774162868/hifumiass-22/ref=nosim/)

## インフラとは？

### ハードウェア＋OS＋ミドルウェア

インフラの役割を「アプリケーションを快適に利用できる環境を作り出すもの」と定義している。

```text
+ - - - - - - - - - - - +
' system                '
'                       '
'       +-------------+ '
'       | application | '
'       +-------------+ '
'       | middleware  | '
' infra | os          | '
'       | hardware    | '
'       +-------------+ '
'                       '
+ - - - - - - - - - - - +
```

 * メモ・個人的解釈
   * 業種業態によって「インフラ」の範囲が大きく異なるため、上図は概ね正確であるという表現に留めるべき。
   * 「インフラ」の説明が難しい理由は、むしろインフラではなく「アプリケーション」にあるのではないだろうか。
   * インフラ (infrastructure) の原意としては、社会基盤を成す構造物であり、支えるものの存在によって成立する。
   * インフラは、アプリケーションという特定の利用目的を持ったプログラム（ソフトウェア）の存在を前提としなければ成り得ない。
   * つまり、インフラを説明するに、それが何のための基盤足り得るかの説明を欠くことは出来ない。

### ハードウェアやミドルウェアの標準化傾向と構築の容易性

「オープン化」と呼ばれる、ハードウェアやミドルウェアの仕様公開と標準化の傾向。

しかし、標準化は「自由な組み合わせ」を提供するが、「容易なインフラ構築」は別の問題である。
単純な機器構成であれば容易に構築し、稼働することができるが、とりわけ大きなシステムを成すために構成が複雑化すると、ただ組み合わせるだけでは想定外の動作不良を招くこともある。

### 非機能要求としてのインフラ

ユーザに提供するサービスを考えた時に、機能要求は主にアプリケーション側で定義される。
そして、そのアプリケーションの提供を「安定」「安全」に行う、いわゆる非機能要求としてインフラが担う役目は大きい。

### インフラデザインパターンとは

アプリケーションの「快適性（非機能要求）」を担うインフラの設計をパターン化したもの。

 * 図示可能
 * 選択基準の存在
 * 特定製品への非依存
 * メリット/デメリットの記載

## Availability

### Keyword

 * SPOF (Single point of failure): 単一障害点。ここが故障するとダウンタイムが発生してしまう。

### Documentation

 * 文書化において「ユーザ」を意識すべき（ここで言う「ユーザ」は文書の読み手のこと。）
 * ユーザの状況を理解し、目的を達成するための過不足ない情報を書き記す
 * 用語集（類語の氾濫を防ぐ）

### Continuous Improvement Process

[ITIL (Information Technology Infrastructure Library) V3](http://ja.wikipedia.org/wiki/Information_Technology_Infrastructure_Library#ITIL_V3)という基準によるステップの定義。

 1. 何を測定すべきかを定義
 1. 何を測定できるのかを定義
 1. データの収集
 1. データの処理
 1. データの分析
 1. 情報の提示と利用
 1. 是正処理の実施

# MySQLサーバデザイン

 * [MySQLをmaster:slave=1:1構成にして参照をslaveに向けるのがなぜ良くないか - 酒日記 はてな支店](http://d.hatena.ne.jp/sfujiwara/20110620/1308531677)
 * [MySQLで参照の負荷分散を行うslaveは3台から構成するのがよいのでは - 酒日記 はてな支店](http://d.hatena.ne.jp/sfujiwara/20110621/1308625519)
 * [データベースのmasterとslaveの使い分けの話。2014年版 - Hateburo: kazeburo hatenablog](http://kazeburo.hatenablog.com/entry/2013/11/27/171652)

## 過去の整理

__Master:Slave=1:1__ という構成で更新をMaster, 参照をSlaveという運用は良くない、という問題提起がされる。

> ___[MySQLをmaster:slave=1:1構成にして参照をslaveに向けるのがなぜ良くないか - 酒日記 はてな支店](http://d.hatena.ne.jp/sfujiwara/20110620/1308531677)___
> 
> 1. 可用性が落ちる
> 1. 全体の性能がほとんど上がらない
> 1. 障害発生時の運用

### Bad pattern: 更新と参照の分離によるアプリケーションサイドの修正必須

#### 1. masterで更新、slaveで参照

```text
+----------------------------------+
|            application           |
+----------------------------------+
        |                   |
        | update            | ref
        v                   v
+--------------+     +-------------+
|    master    | --- |    slave    |
+--------------+     +-------------+
```

#### 2. masterに障害が発生する

更新系の処理が不能になる

```text
+----------------------------------+
|            application           |
+----------------------------------+
        |                   |
        x update            | ref
        v                   v
+--------------+     +-------------+
|  X master    | --- |    slave    |
+--------------+     +-------------+
```

#### 3. slaveをmasterに昇格させる

```text
+----------------------------------+
|            application           |
+----------------------------------+
        |                   |
        x update            | ref
        v                   v
+--------------+     +-------------+
|  X master    |     |   master    |
+--------------+     +-------------+
```

#### 4. application側で新masterへupdateするように変更する

懸念点：application側の修正が必要になる？

```text
+----------------------------------+
|            application           |
+----------------------------------+
                  \         |
                   \ update | ref
                    \       v
+--------------+     +-------------+
|  X master    |     |   master    | < え、俺全部やらないとダメなの？！
+--------------+     +-------------+
```

## 2014年からは強いmasterで全部やればいいかもしれない

> ___[データベースのmasterとslaveの使い分けの話。2014年版 - Hateburo: kazeburo hatenablog](http://kazeburo.hatenablog.com/entry/2013/11/27/171652)___
> 
> 最近、新しくサービスができたり、新規機能でデータベースを追加する際には必ず全ての参照をmasterに向けてもらっています。理由は上記のエントリを読んでください。このような構成が取れるのはもちろん性能的にそれで問題ないからです。
> 
> 新しいハードウェアに、設定されたMySQL、問題のないように書かれたSQLであれば、数千QPSは余裕に、また少し頑張れば数万QPSを一台で賄えます。なので大体のサービスはmaster一台で十分です。

### New pattern: 強力な筐体による更新・参照処理

#### 1. masterで更新・参照を受け持ち、slaveはreplication only

```text
+----------------------------------+
|            application           |
+----------------------------------+
   |        |
   | update | ref
   v        v
+--------------+     +-------------+
|    master    | --- |    slave    | < replication only
+--------------+     +-------------+
 / 強いサーバ \
/  で頑張る！  \
```

#### 2. Masterが死ぬとSlaveが昇格する

```text
+----------------------------------+
|            application           |
+----------------------------------+
   |        |
   | update | ref
   v        v
+--------------+     +-------------+
|  X master    |     |    master   | < 昇格
+--------------+     +-------------+
```

#### 3. 筐体のIPアドレスを入れ替え、アプリケーションサーバには手を加えずに交換する

```text
+----------------------------------+
|            application           |
+----------------------------------+
   |        |
   | update | ref
   v        v
+--------------+
|    master    | ==3
+--------------+
 / IP付け替え \
   
R.I.P 
+--------------+
|  X master    |
+--------------+
```